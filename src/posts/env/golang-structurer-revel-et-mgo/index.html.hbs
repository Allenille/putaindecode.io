---
lang: fr
layout: post.hbs
type: post
draft: true
comments: true
author: OwlyCode
title: Structurer son projet avec Revel et Mgo
tags:
  - golang
  - mongo
  - revel
  - mgo
readingTime: 15min
---

{{#markdown}}
Tu te sens l’âme d’un rebelle ? Tu veux tester de la techno atypique ? Ça tombe bien, aujourd’hui on est là pour ça.  Je t’apprends sûrement pas ce qu’est le langage Go, apparu fin 2009 comme un véritable ovni, de toutes façons c’est pas le but de cet article. Si tu ne connais pas, je t’invite à aller sur la homepage du projet (lien disponible ci dessous) et à parcourir le go-tour, un showcase complet du langage.

#Les technos utilisées
Golang / http://golang.org/  
Langage compilé, communément considéré comme “désorienté objet”, c’est une alternative solide au C/C++ qui prône un découpage modulaire (par “package”) des applications. Il est prédisposé à une utilisation en développement web grâce à un package natif de gestion des réseaux et du protocole http.

Revel / http://robfig.github.io/revel/  
Framework développé en Go et pour Go. Il intègre tout ce qu’il faut pour développer une application web : rechargement du code à chaud, gestion des urls par routing, parsing des paramètres GET et POST, mécanisme de validation des données, gestion de sessions, gestion du cache, framework de tests et même moteur de tâches planifiées cron-likes. Il a pour particularité d’être complètement agnostique à l’heure actuelle sur la partie modèle et ne fourni aucun ORM, ODM, ni même l’ombre d’un driver pour Mysql.

Mgo / http://labix.org/mgo  
Driver Go complet pour MongoDB, permettant d’établir la connexion et d’envoyer des requêtes. Il dispose d’un mécanisme de mapping des documents mongodb sur les type struct de Go.

MongoDB / http://www.mongodb.org/  
Base de données NoSql agile et scalable, les documents sont stockés au format json dans des collections. Le requêtage se fait en manipulant des objets et des fonctions javascript.

#Let’s Go
On va partir du principe que tu as Go et Revel prêts pour la baston. On attaque direct à sec par le classique “revel new” puisqu'on va partir de la structure de base.

```
revel new github.com/OwlyCode/PutainDeProjet
```

Là théoriquement, tu te retrouves avec la structure par défaut du boilerplate revel, quelque chose comme ça:

// @TODO Screen app skeleton

C’est là qu’on se met au boulot. On a de quoi faire un site complet avec ça mais aucune trace de gestion de base de données là dedans. On commence donc par créer un dossier `app/modules` et un sous dossier `app/modules/mongo`. C’est dans ce dossier que va se trouver notre gestionnaire de connexion à mongoDB. En fait ce n’est rien de plus qu’un binding entre Revel et Mgo :

```go
package mongo

import (
    "github.com/robfig/revel"
    "labix.org/v2/mgo"
    "sync"
)

// Extension du controlleur.
type Mongo struct {
    *revel.Controller
    MongoSession  *mgo.Session
    MongoDatabase *mgo.Database
}

// Stockage global de la session mais dont la visibilité est restreinte au package.
var session *mgo.Session

// Singleton
var dial sync.Once

// Renvoie la session mgo en cours, si aucune n'existe, elle est créée.
func GetSession() *mgo.Session {

    host, _ := revel.Config.String("mongo.host")

    // Grâce au package sync cette fonction n'est appelée 
    // qu'une seule fois et de manière synchrone.
    dial.Do(func() { 
        var err error
        session, err = mgo.Dial(host)
        if err != nil {
            panic(err)
        }
    })

    return session
}

// Alimente les propriétés affectées au controlleur 
func (c *Mongo) Bind() revel.Result {
    // Oublie pas de mettre mongo.database dans le app.conf, genre "localhost"
    databaseName, _ := revel.Config.String("mongo.database")
    
    c.MongoSession = GetSession()
    c.MongoDatabase = c.MongoSession.DB(databaseName)

    return nil
}

// Fonction appelée au chargement de l'application.
// Elle effectue un appel a notre fonction Bind avant 
// chaque execution du controlleur.
func init() {
    revel.InterceptMethod((*Mongo).Bind, revel.BEFORE)
}
```

On a créé notre connexion à mongo, mais maintenant on va aussi l’utiliser. Dans le contrôleur, rien de plus simple : 

```go
import (
    "github.com/robfig/revel"
    "github.com/OwlyCode/PutainDeProjet/app/modules/mongo"
)

type AppController struct {
    *revel.Controller
    mongo.Mongo
}

func (c *AppController) Index() revel.Result {
    usersCollection := c.MongoDatabase.C("users")
    // tu peux maintenant manipuler ta mgo.Collection.
    // [ ... ]
}
```

Mais tu peux aussi l’appeler ailleurs dans le projet, par exemple dans un autre module :

```go
import (
    "github.com/OwlyCode/PutainDeProjet/app/modules/mongo"
)

func DoStuff(user *models.User) {
    session := mongo.GetSession()
    // tu peux maintenant manipuler ta mgo.Session.
    // [ ... ]
}
```

**C'est bien beau de copier coller mais ...**  
... tu te demandes certainement pourquoi on a créé un dossier `app/modules`, si c’est pour n’y mettre qu’un sous dossier mongo dedans. Et c’est une très bonne question. En fait, notre dossier mongo représente un module du projet bien délimité. A l’avenir, si tu veux aussi brancher du mysql, et bien y a juste à créer `app/modules/mysql`. Rien ne change pour l’existant et tu ne pollues pas la racine de ton projet. L’autre avantage c’est qu’en un coup d’oeil dans ce dossier tu as un aperçu direct des features de l’application.

#Modèles globaux, modèles locaux
J’ai évoqué plus haut dans la liste des technos une feature hyper sexy de mgo : le mapping sur les types struct. Ce qui veut dire qu’avec mgo, on peut créer des modèles structurés. Certains seront communs à toute l’application, par exemple un utilisateur, mais d’autres seront spécifiques à un module, comme par exemple une facture.

Une bonne pratique est d’approcher le rangement des modèles selon cette structure:

// @TODO screen archi locale/globale

// @TODO La suite ...

{{/markdown}}
